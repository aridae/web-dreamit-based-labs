Один путь отражает одну сущность, с которой можно работать через внешнее апи.

Все названия сущностей во множественном числе, причем: 
* /events -- работа с коллекцией 
* /events/{id} -- работа с одним объектом из коллекции

Все остальные параметры для фильтрации передаются только как query parameters, то есть:
* /events?room=1 -- все ивенты для комнаты 1
* /events?author=1 -- все ивенты для автора 1 

Это разные юскейсы, но для них один хэндлер, тк 
на путь /events можно зарегистрировать только один обработчик.

В этом обработчике все query parameters можно достать из запроса и засканить в структуру Filter

Каждый валидный набор параметров логически мапится на один юскейс, если не мапится -- это получается бэд реквесть.

Наш бедный хэндлер хватает все запросы по пути /events, смотрит какие были переданы параметры и дальше маршрутизирует на нужный метод бизнес логики


****

Кроме того, у нас есть сущность comments -- ee особенность в том, что мы не можем обрабатывать ее отдельно от notify
Типа получить коллкекцию комментариев, с каким либо-фильтром, кроме нотифая -- не имеет никакого смысла.
Поэтому это единственная коллекция, которую я получаю как вложенный путь.

Надеюсь, за это не бьют, но решение /comments?event=1 прям страшно выглядит, как будто ивент тут опция коммента, а он на самом деле обязателен.

**** 

Тогда наши хэндлеры: 

Бронь на события 
* /events 
    * ?author=...
    * ?room=...
* /events/{id}


Инвайты на события 
* /invites
    * ?event=...
    * ?receiver=...
* /invites/{id}


Комнаты 
* /rooms
* /rooms/{id}


Нотифаи (уведомления/инфа по событию)
* /notifies
    * ?event=...
    * ?subject=...
    * ?tag=...
* /notifies/{id}


Комментарии -- привязаны к конкретному нотифаю
* /notifies/{id}/comments
    * ?author=..
* /notifies/{id}/comments/{id}