# DreamIt API

## Тестирование мать его за ногу 

### Лаба 1 - unit-тесты для компонентов доступа к данным и бизнес-логики
* один класс == один test-suit с минимум тремя тестами 
* для каждого теста соблюдена структура arrange-act-assert с исп fixture и др классов/методов хелперов  
* тесты должны быть как в классическом, так и в лондонском вариантах + обоснование, где какой нужен 
* варианты использования mock/stub 
* дб тесты с исп паттерна data builder (опц object mother)
* настроить локальный запуск тестов
* защита от регрессии и устойчивость к рефакторингу 

Тестируем компоненты доступа к данным и бизнес-логику - ок
В случае лондонского подхода надо замокать классы, от которых зависят репозитории, чтобы полностью изолировать тестируемые классы от всех зависимостей 
В случае классического подхода, надо замокать обращение к бд -- это и есть репозитории(?)

Поэтому: 
* тестируем методы доступа к данным, где происходит какая-то предобработка данных, 
* мокаем репозитории, которые только оберточки, 
* все остальные зависимости стабаем заглушками

В чем мем юнит тестирования -- тестируем маленький кусочек кода быстренько и изолированно(!) от другого кода.

Два подхода: лондонская школа и классическая. Различия в том, как и что изолируем.

Лондонская школа -- изолируем тестируемый код от его зависимостей. (Если класс имеет зависимость от другого класса, то все такие зависимости заменяем заглушками - test doubles). Юнит == один класс или метод внутри класса. Нужно много моков -- для всех зависимостей.

Классический подход -- изолируется не рабочий код, а сами тесты друг от друга -- можно тесты запускать параллельно и в любом порядке при условии, что нет обращения к разделяемым данным, типа БД, ФС и тд. Юнит == класс или неск классов рабочего кода, которые зависят друг от друга. 

Лондонская школа: изолирует юниты, юнит == класс, мокает любые изменяемые зависимости.
(+) Лучшая детализация и гранулярность тестов.

Классическая школа: изолирует юнит-тесты, юнит == класс или набор классов, мокает только внепроцессные зависимости, типа ФС и БД.
(+) Лучшая целостность, тк теструются зависимые классы вместе (зачем тестировать лапы и хвост, если можно протестировать собаку) ((господи, прости))


### Лаба 2 - integration-тесты и e2e-тест для компонентов доступа к данным и бизнес-логики
* integration-тесты для компонентов доступа к данным и бизнес-логики: 
    * хотя бы два теста на два класса без моков и стабов 
    * хотя бы два теста где тестируется более двух классов 
* e2e тест для демонстрации сценария: 
    * включает в себя взаимодействие с БД
    * заменяем UI хелпером - имитируем события, типа клика 
    * возможность запустить N раз и посмотреть сколько раз выполнилось
* запуск тестов в CI/CD (порядок: UI, integration, e2e) 
* имитируем действия из e2e с помощью средства для отправки запросов и снимаем логи средством для захвата траффика 

У меня все классы зависят от бд -- чтобы без моков надо поднимать бд в контейнере.

Integration-тестирования вкратце: 
* в Makefile закинуть команды для тестирования 
* композником поднять все зависимости - бд, фс и тд 
* написать сами тесты 
* запустить их командой мейкфайла 

---


Цель работы: создание приложения для бронирования переговорок для бизнес-клиента.

Методы доступны только для авторизованного пользователя.

* Пользователь имеет возмозность просматривать все переговорные комнаты, доступные для брони в систем.Список комнат заносится в базу данных администратором.

* Пользователь имеет возможность просматривать события, на которые была забронирована каждая из переговорных.

* Пользователь имеет возомжность забонировать переговорную на событие с указаением даты и времени события.

* Пользователь имеет возможность перенести событие на другую дату.

* Пользователь имеет возомжность удалить событие, автором которого он является.

* WIP: Пользователь имеет возможность внести в профиль информацию о себе и установить аватар.





## Команды для докера 

Это шпора, а не пайплайн -- не надо их все запускать)))

Cобрать контейнеры: 
```bash
docker-compose up -d --force-recreate --remove-orphans
```

Посмотреть логи 
```bash
docker-compose logs -f
```

Зайти в бд, глянуть что там как
```bash 
psql -h localhost -p 5432 -d dreamit_api_db -U postgres
```

Вывод примерно такой должен быть:
```bash
dreamit_api_db=# \dt
             List of relations
 Schema |     Name      | Type  |  Owner   
--------+---------------+-------+----------
 public | auth_services | table | postgres
 public | auth_tokens   | table | postgres
 public | calendar      | table | postgres
 public | intervals     | table | postgres
 public | rooms         | table | postgres
 public | schedules     | table | postgres
 public | users         | table | postgres
```

Почистить вольюмы по имени: 
```bash
docker rm -fv <container-name>
```

В частности, может понадобиться почистить постгру: 
```bash
docker rm -fv postgresdreamit
```

Уничтожить и подчистить все контейнеры на машине:
```bash
make armageddon
```

Глянуть все контейнеры на машине: 
```bash
docker ps --all
```

Или вот так: 
```bash
docker container ls --all
```

## Вики для разбора теории по лабе

Желаю всем создателям этого курса получасового сна и кофеиновой интоксикации :)
